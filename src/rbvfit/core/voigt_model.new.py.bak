"""
Picklable VoigtModel implementation that supports multiprocessing.
"""

from __future__ import annotations
from typing import Dict, List, Tuple, Optional, Any, Union
import numpy as np
from scipy.special import wofz
from astropy.convolution import convolve as astropy_convolve, Gaussian1DKernel, CustomKernel
from dataclasses import dataclass
import copy

# Import configuration and parameter management
from rbvfit.core.fit_configuration import FitConfiguration
from rbvfit.core.parameter_manager import ParameterManager
from rbvfit import rb_setline as rb

# Try to import linetools for COS LSF
try:
    from linetools.spectra.lsf import LSF
    HAS_LINETOOLS = True
except ImportError:
    HAS_LINETOOLS = False


def voigt_tau(lambda0: float, gamma: float, f: float, N: float, b: float, 
              wv: np.ndarray) -> np.ndarray:
    """
    Module-level Voigt profile calculation for maximum performance.
    
    Parameters
    ----------
    lambda0 : float
        Rest wavelength in Angstroms
    gamma : float
        Damping parameter
    f : float
        Oscillator strength
    N : float
        Column density in linear scale
    b : float
        Doppler parameter in km/s
    wv : np.ndarray
        Wavelength array in Angstroms (rest frame)
        
    Returns
    -------
    np.ndarray
        Optical depth array
    """
    c = 29979245800.0  # cm/s
    b_f = b / lambda0 * 10**13
    a = gamma / (4 * np.pi * b_f)
    
    freq0 = c / lambda0 * 10**8
    freq = c / wv * 10**8
    
    constant = 448898479.507
    constant /= freq0 * b * 10**5
    
    x = (freq - freq0) / b_f
    H = np.real(wofz(x + 1j * a))
    
    tau = N * f * constant * H
    return tau


def _evaluate_compiled_model(data_container, theta: np.ndarray, wavelength: np.ndarray) -> np.ndarray:
    """
    Global function to evaluate compiled Voigt model. This function is picklable.
    
    Parameters
    ----------
    data_container : CompiledModelData
        Container with pre-computed model data
    theta : np.ndarray
        Parameter array
    wavelength : np.ndarray
        Wavelength array
        
    Returns
    -------
    np.ndarray
        Model flux
    """
    atomic_lambda0 = data_container.atomic_lambda0
    atomic_gamma = data_container.atomic_gamma
    atomic_f = data_container.atomic_f
    z_factors = data_container.z_factors
    N_indices = data_container.N_indices
    b_indices = data_container.b_indices
    v_indices = data_container.v_indices
    kernel = data_container.kernel
    n_lines = data_container.n_lines

    N_linear = 10**theta[N_indices]
    b_values = theta[b_indices]
    v_values = theta[v_indices]

    tau_total = np.zeros_like(wavelength, dtype=np.float64)
    c = 299792.458

    for i in range(n_lines):
        z_total = z_factors[i] * (1 + v_values[i]/c) - 1
        wave_rest = wavelength / (1 + z_total)
        
        tau = voigt_tau(
            atomic_lambda0[i], atomic_gamma[i], atomic_f[i],
            N_linear[i], b_values[i], wave_rest
        )
        
        tau_total += tau

    flux = np.exp(-tau_total)

    if kernel is not None:
        flux = astropy_convolve(flux, kernel, boundary="extend")

    return flux


@dataclass
class CompiledModelData:
    """
    Data container for compiled model. This class only holds data and is picklable.
    """
    atomic_lambda0: np.ndarray
    atomic_gamma: np.ndarray
    atomic_f: np.ndarray
    z_factors: np.ndarray
    N_indices: np.ndarray
    b_indices: np.ndarray
    v_indices: np.ndarray
    kernel: Optional[Any]
    n_lines: int
    total_components: int


class CompiledVoigtModel:
    """
    Compiled Voigt model that can be pickled for multiprocessing.
    
    This class is a thin wrapper around the data container and delegates
    computation to module-level functions.
    """
    
    def __init__(self, data_container: CompiledModelData):
        """Initialize with data container."""
        self.data = data_container
    
    def model_flux(self, theta: np.ndarray, wavelength: np.ndarray) -> np.ndarray:
        """
        Evaluate model flux. Compatible with v1 interface.
        
        Parameters
        ----------
        theta : np.ndarray
            Parameter array
        wavelength : np.ndarray
            Wavelength array
            
        Returns
        -------
        np.ndarray
            Model flux
        """
        return _evaluate_compiled_model(self.data, theta, wavelength)
    
    def __call__(self, theta: np.ndarray, wavelength: np.ndarray) -> np.ndarray:
        """Make the object callable for convenience."""
        return self.model_flux(theta, wavelength)
    
    def __getstate__(self):
        """Custom pickling - only pickle the data."""
        return {'data': self.data}
    
    def __setstate__(self, state):
        """Custom unpickling - restore from data."""
        self.data = state['data']


class VoigtModel:
    """
    Enhanced Voigt profile model with picklable compilation.
    """
    
    def __init__(self, config: FitConfiguration, FWHM: Union[str, float] = '6.5',
                 grating: str = 'G130M', life_position: str = '1', 
                 cen_wave: str = '1300A'):
        """Initialize the Voigt model."""
        self.config = config
        self.config.validate()
        self.param_manager = ParameterManager(config)
        
        # Store LSF parameters
        self.FWHM = FWHM
        self.grating = grating
        self.life_position = life_position
        self.cen_wave = cen_wave
        
        # Set up convolution kernel
        self._setup_kernel()
        
        # Pre-compute arrays for fast evaluation
        self._cache_atomic_parameters()
        self._setup_fast_mapping()
        
        # Compilation state
        self._compiled = False
    
    def _cache_atomic_parameters(self):
        """Cache all atomic parameters as flat arrays during initialization."""
        
        # Collect all lines in order
        line_data = []
        for system in self.config.systems:
            for ion_group in system.ion_groups:
                for wavelength in ion_group.transitions:
                    for comp_idx in range(ion_group.components):
                        line_info = rb.rb_setline(wavelength, 'closest')
                        line_data.append({
                            'lambda0': line_info['wave'][0],
                            'gamma': line_info['gamma'][0],
                            'f_osc': line_info['fval'][0],
                            'z': system.redshift
                        })
        
        # Convert to flat numpy arrays
        self.atomic_lambda0 = np.array([line['lambda0'] for line in line_data])
        self.atomic_gamma = np.array([line['gamma'] for line in line_data])
        self.atomic_f = np.array([line['f_osc'] for line in line_data])
        
        # Redshift factors as array
        self.z_factors = np.array([1.0 + line['z'] for line in line_data])
        
        # Store number of lines
        self.n_lines = len(line_data)

    def _setup_fast_mapping(self):
        """Set up fast parameter index arrays."""
        
        # Calculate total components
        self.total_components = sum(
            ion_group.components 
            for system in self.config.systems 
            for ion_group in system.ion_groups
        )
        
        # Create parameter index arrays
        indices = []
        global_comp_idx = 0
        
        for system in self.config.systems:
            for ion_group in system.ion_groups:
                # For each transition in this ion group
                for wavelength in ion_group.transitions:
                    # Each transition uses ALL components of this ion
                    for comp_idx in range(ion_group.components):
                        indices.append(global_comp_idx + comp_idx)
                
                # After processing all transitions, advance to next ion group
                global_comp_idx += ion_group.components
        
        # Convert to numpy arrays for direct indexing
        self.N_indices = np.array(indices)
        self.b_indices = np.array(indices) + self.total_components
        self.v_indices = np.array(indices) + 2 * self.total_components

    def _setup_kernel(self):
        """Set up the convolution kernel based on FWHM parameter."""
        if self.FWHM == 'COS':
            if not HAS_LINETOOLS:
                raise ImportError("COS LSF requires linetools package")
            instr_config = dict(
                name='COS',
                grating=self.grating,
                life_position=self.life_position,
                cen_wave=self.cen_wave
            )
            coslsf = LSF(instr_config)
            _, data = coslsf.load_COS_data()
            self.kernel = CustomKernel(data[self.cen_wave].data)
        else:
            fwhm_pixels = float(self.FWHM)
            sigma = fwhm_pixels / 2.355
            self.kernel = Gaussian1DKernel(stddev=sigma)

    def compile(self) -> CompiledVoigtModel:
        """
        Compile the model for fast evaluation. Returns a picklable object.
        
        Returns
        -------
        CompiledVoigtModel
            Compiled model that can be pickled and used with multiprocessing
        """
        # Create data container with all necessary information
        data_container = CompiledModelData(
            atomic_lambda0=self.atomic_lambda0.copy(),
            atomic_gamma=self.atomic_gamma.copy(),
            atomic_f=self.atomic_f.copy(),
            z_factors=self.z_factors.copy(),
            N_indices=self.N_indices.copy(),
            b_indices=self.b_indices.copy(),
            v_indices=self.v_indices.copy(),
            kernel=copy.deepcopy(self.kernel),  # Deep copy to avoid reference issues
            n_lines=self.n_lines,
            total_components=self.total_components
        )
        
        # Return compiled model
        compiled_model = CompiledVoigtModel(data_container)
        self._compiled = True
        
        return compiled_model
    
    def evaluate(self, theta: np.ndarray, wavelength: np.ndarray, 
                 return_components: bool = False, return_unconvolved: bool = False,
                 validate_theta: bool = False) -> Union[np.ndarray, Dict[str, Any]]:
        """
        Evaluate the Voigt model - flexible version for analysis.
        """
        if validate_theta:
            self.param_manager.validate_theta(theta)
        
        # Direct evaluation using the global function
        data_container = CompiledModelData(
            atomic_lambda0=self.atomic_lambda0,
            atomic_gamma=self.atomic_gamma,
            atomic_f=self.atomic_f,
            z_factors=self.z_factors,
            N_indices=self.N_indices,
            b_indices=self.b_indices,
            v_indices=self.v_indices,
            kernel=None if return_unconvolved else self.kernel,
            n_lines=self.n_lines,
            total_components=self.total_components
        )
        
        flux_total = _evaluate_compiled_model(data_container, theta, wavelength)
        
        if return_components:
            return {
                'total': flux_total,
                'components': [],
                'component_info': []
            }
        else:
            return flux_total
    
    @property
    def is_compiled(self) -> bool:
        """Check if model is compiled for fast evaluation."""
        return self._compiled
    
    def get_info(self) -> str:
        """Get model configuration summary."""
        lines = ["VoigtModel Summary", "=" * 50]
        lines.append(self.config.summary())
        
        if self.FWHM == 'COS':
            lines.append(f"\nLSF: COS {self.grating} LP{self.life_position}")
        else:
            lines.append(f"\nLSF: Gaussian FWHM = {self.FWHM} pixels")
        
        lines.append(f"\nModel state:")
        lines.append(f"  Compiled: {self._compiled}")
        lines.append(f"  Lines: {self.n_lines}")
        lines.append(f"  Components: {self.total_components}")
            
        return "\n".join(lines)


# Test function to verify pickling works
def test_pickling():
    """Test that the compiled model can be pickled."""
    import pickle
    
    # Create a simple test model
    config = FitConfiguration()
    config.add_system(z=0.348, ion='MgII', transitions=[2796.3, 2803.5], components=2)
    
    model = VoigtModel(config, FWHM='6.5')
    compiled_model = model.compile()
    
    # Test pickling
    try:
        pickled_data = pickle.dumps(compiled_model)
        unpickled_model = pickle.loads(pickled_data)
        print("✓ Pickling test passed!")
        
        # Test that it still works
        theta = np.array([13.5, 13.2, 15.0, 20.0, -50.0, 0.0])
        wave = np.linspace(3750, 3850, 100)
        
        original_flux = compiled_model.model_flux(theta, wave)
        unpickled_flux = unpickled_model.model_flux(theta, wave)
        
        if np.allclose(original_flux, unpickled_flux):
            print("✓ Functionality test passed!")
        else:
            print("✗ Functionality test failed!")
            
    except Exception as e:
        print(f"✗ Pickling test failed: {e}")


if __name__ == "__main__":
    test_pickling()