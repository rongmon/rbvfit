"""
Core Voigt profile model for rbvfit 2.0 with compilation for MCMC performance.
"""

from __future__ import annotations
from typing import Dict, List, Tuple, Optional, Any, Union
import numpy as np
from scipy.special import wofz
from astropy.convolution import convolve as astropy_convolve, Gaussian1DKernel, CustomKernel
from dataclasses import dataclass

# Import configuration and parameter management
from rbvfit.core.fit_configuration import FitConfiguration
from rbvfit.core.parameter_manager import ParameterManager
from rbvfit import rb_setline as rb

# Try to import linetools for COS LSF
try:
    from linetools.spectra.lsf import LSF
    HAS_LINETOOLS = True
except ImportError:
    HAS_LINETOOLS = False


def voigt_tau(lambda0: float, gamma: float, f: float, N: float, b: float, 
              wv: np.ndarray) -> np.ndarray:
    """
    Module-level Voigt profile calculation for maximum performance.
    
    Parameters
    ----------
    lambda0 : float
        Rest wavelength in Angstroms
    gamma : float
        Damping parameter
    f : float
        Oscillator strength
    N : float
        Column density in linear scale
    b : float
        Doppler parameter in km/s
    wv : np.ndarray
        Wavelength array in Angstroms (rest frame)
        
    Returns
    -------
    np.ndarray
        Optical depth array
    """
    c = 29979245800.0  # cm/s
    b_f = b / lambda0 * 10**13
    a = gamma / (4 * np.pi * b_f)
    
    freq0 = c / lambda0 * 10**8
    freq = c / wv * 10**8
    
    constant = 448898479.507
    constant /= freq0 * b * 10**5
    
    x = (freq - freq0) / b_f
    H = np.real(wofz(x + 1j * a))
    
    tau = N * f * constant * H
    return tau

class CompiledVoigt:
    """
    Compiled Voigt model containing pure functions for MCMC performance.
    """
    def __init__(self, pure_func):
        self.simple_flux = pure_func
        
    def __call__(self, theta, wave):
        """Allow direct calling: compiled_voigt(theta, wave)"""
        return self.simple_flux(theta, wave)

class VoigtModel:
    """
    Voigt profile model with multi-group support and compilation for MCMC performance.
    
    Parameters
    ----------
    config : FitConfiguration
        The fitting configuration defining systems and ions
    FWHM : str or float, optional
        Line spread function specification (default: '6.5')
    grating : str, optional
        HST grating name if FWHM='COS' (default: 'G130M')
    life_position : str, optional
        HST lifetime position if FWHM='COS' (default: '1')
    cen_wave : str, optional
        Central wavelength for COS LSF (default: '1300A')
    """
    
    def __init__(self, config: FitConfiguration, FWHM: Union[str, float] = '6.5',
                 grating: str = 'G130M', life_position: str = '1', 
                 cen_wave: str = '1300A'):
        """Initialize the Voigt model."""
        self.config = config
        self.config.validate()
        self.param_manager = ParameterManager(config)
        
        # Store LSF parameters
        self.FWHM = FWHM
        self.grating = grating
        self.life_position = life_position
        self.cen_wave = cen_wave
        
        # Set up convolution kernel
        self._setup_kernel()
        
        # Pre-compute arrays for fast evaluation
        self._cache_atomic_parameters()
        self._setup_fast_mapping()
        
        # Compilation state
        self._compiled = False
        self.model_flux = None
    
    def _cache_atomic_parameters(self):
        """Cache all atomic parameters as flat arrays during initialization."""
        
        # Collect all lines in order
        line_data = []
        for system in self.config.systems:
            for ion_group in system.ion_groups:
                for wavelength in ion_group.transitions:
                    for comp_idx in range(ion_group.components):
                        line_info = rb.rb_setline(wavelength, 'closest')
                        line_data.append({
                            'lambda0': line_info['wave'][0],
                            'gamma': line_info['gamma'][0],
                            'f_osc': line_info['fval'][0],
                            'z': system.redshift
                        })
        
        # Convert to flat numpy arrays
        self.atomic_lambda0 = np.array([line['lambda0'] for line in line_data])
        self.atomic_gamma = np.array([line['gamma'] for line in line_data])
        self.atomic_f = np.array([line['f_osc'] for line in line_data])
        
        # Redshift factors as array
        self.z_factors = np.array([1.0 + line['z'] for line in line_data])
        
        # Store number of lines
        self.n_lines = len(line_data)

    def _setup_fast_mapping(self):
        """Set up fast parameter index arrays."""
        
        # Calculate total components
        self.total_components = sum(
            ion_group.components 
            for system in self.config.systems 
            for ion_group in system.ion_groups
        )
        
        # Create parameter index arrays
        indices = []
        global_comp_idx = 0
        
        for system in self.config.systems:
            for ion_group in system.ion_groups:
                # For each transition in this ion group
                for wavelength in ion_group.transitions:
                    # Each transition uses ALL components of this ion
                    for comp_idx in range(ion_group.components):
                        indices.append(global_comp_idx + comp_idx)
                
                # After processing all transitions, advance to next ion group
                global_comp_idx += ion_group.components
        
        # Convert to numpy arrays for direct indexing
        self.N_indices = np.array(indices)
        self.b_indices = np.array(indices) + self.total_components
        self.v_indices = np.array(indices) + 2 * self.total_components

    def _setup_kernel(self):
        """Set up the convolution kernel based on FWHM parameter."""
        if self.FWHM == 'COS':
            if not HAS_LINETOOLS:
                raise ImportError("COS LSF requires linetools package")
            instr_config = dict(
                name='COS',
                grating=self.grating,
                life_position=self.life_position,
                cen_wave=self.cen_wave
            )
            coslsf = LSF(instr_config)
            _, data = coslsf.load_COS_data()
            self.kernel = CustomKernel(data[self.cen_wave].data)
        else:
            fwhm_pixels = float(self.FWHM)
            sigma = fwhm_pixels / 2.355
            self.kernel = Gaussian1DKernel(stddev=sigma)
    
    def compile(self) -> CompiledVoigt:
        """
        Compile the model into a pure function object.
        
        Returns
        -------
        CompiledVoigt
            Object containing pure function for MCMC performance
        """
        # Capture all pre-computed data (same as before)
        atomic_lambda0 = self.atomic_lambda0.copy()
        atomic_gamma = self.atomic_gamma.copy()
        atomic_f = self.atomic_f.copy()
        z_factors = self.z_factors.copy()
        N_indices = self.N_indices.copy()
        b_indices = self.b_indices.copy()
        v_indices = self.v_indices.copy()
        kernel = self.kernel
        n_lines = self.n_lines

        
        def pure_model_func(theta, wavelength):
            """Pure function: (theta, wavelength) -> flux."""
            # Same implementation as before
            N_linear = 10**theta[N_indices]
            b_values = theta[b_indices]
            v_values = theta[v_indices]
            
            tau_total = np.zeros_like(wavelength, dtype=np.float64)
            c = 299792.458
            
            for i in range(n_lines):
                z_total = z_factors[i] * (1 + v_values[i]/c) - 1
                wave_rest = wavelength / (1 + z_total)
                
                tau = voigt_tau(
                    atomic_lambda0[i], atomic_gamma[i], atomic_f[i],
                    N_linear[i], b_values[i], wave_rest
                )
                
                tau_total += tau
            
            flux = np.exp(-tau_total)
            
            if kernel is not None:
                flux = astropy_convolve(flux, kernel, boundary='extend')
            
            return flux
    
        return CompiledVoigt(pure_model_func)
    
    def evaluate(self, theta: np.ndarray, wavelength: np.ndarray, 
                 return_components: bool = False, return_unconvolved: bool = False,
                 validate_theta: bool = False) -> Union[np.ndarray, Dict[str, Any]]:
        """
        Evaluate the Voigt model - flexible version for analysis.
        """
        if validate_theta:
            self.param_manager.validate_theta(theta)
        
        # Direct evaluation (same as existing code)
        N_linear = 10**theta[self.N_indices]
        b_values = theta[self.b_indices]
        v_values = theta[self.v_indices]
        
        tau_total = np.zeros_like(wavelength, dtype=np.float64)
        c = 299792.458
        
        for i in range(self.n_lines):
            z_total = self.z_factors[i] * (1 + v_values[i]/c) - 1
            wave_rest = wavelength / (1 + z_total)
            
            tau = voigt_tau(
                self.atomic_lambda0[i], self.atomic_gamma[i], self.atomic_f[i],
                N_linear[i], b_values[i], wave_rest
            )
            
            tau_total += tau
        
        flux_total = np.exp(-tau_total)
        
        if not return_unconvolved and self.kernel is not None:
            flux_total = astropy_convolve(flux_total, self.kernel, boundary='extend')
        
        if return_components:
            return {
                'total': flux_total,
                'components': [],
                'component_info': []
            }
        else:
            return flux_total
    
    @property
    def is_compiled(self) -> bool:
        """Check if model is compiled for fast evaluation."""
        return self._compiled
    
    def force_recompile(self):
        """Force recompilation."""
        self._compiled = False
        self.model_flux = None
        self.compile()
    
    def get_info(self) -> str:
        """Get model configuration summary."""
        lines = ["VoigtModel Summary", "=" * 50]
        lines.append(self.config.summary())
        
        if self.FWHM == 'COS':
            lines.append(f"\nLSF: COS {self.grating} LP{self.life_position}")
        else:
            lines.append(f"\nLSF: Gaussian FWHM = {self.FWHM} pixels")
        
        lines.append(f"\nModel state:")
        lines.append(f"  Compiled: {self._compiled}")
        lines.append(f"  Lines: {self.n_lines}")
        lines.append(f"  Components: {self.total_components}")
            
        return "\n".join(lines)